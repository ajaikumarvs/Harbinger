# modules/malware_scanner/scanner.py

import os
import hashlib
import logging
import asyncio
import yara
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Union, Any
from pathlib import Path

from ..common.base_scanner import (
    BaseScanner,
    ScanResult,
    ScanProgress,
    ScanStatus,
    InitializationError,
    ScanError,
    ResourceError
)

class ScanType(Enum):
    QUICK = "quick"    # Signature-only scan
    NORMAL = "normal"  # Standard scan with basic heuristics
    DEEP = "deep"     # Deep scan with advanced heuristics

@dataclass
class ScanTarget:
    """Represents a target for scanning"""
    path: Path
    is_directory: bool
    size: int = 0
    
    @classmethod
    def from_path(cls, path: Union[str, Path]) -> 'ScanTarget':
        path = Path(path)
        return cls(
            path=path,
            is_directory=path.is_dir(),
            size=path.stat().st_size if path.is_file() else 0
        )

class BinaryHunter(BaseScanner[ScanTarget]):
    """
    Binary Hunter (binhunt) malware scanner module for Harbinger.
    Provides comprehensive binary analysis capabilities including signature matching,
    YARA rule scanning, and heuristic analysis.
    """
    
    def __init__(self, timeout: float = 300.0):
        super().__init__(timeout=timeout)
        self.yara_rules = None
        self.signature_db = {}
        self._concurrent_scans = os.cpu_count() or 2
        self._semaphore = None  # Will be initialized in initialize()
        
    @property
    def name(self) -> str:
        return "binhunt"
        
    @property
    def version(self) -> str:
        return "1.0.0"

    async def initialize(self) -> bool:
        """Initialize scanner resources including YARA rules and signature database."""
        try:
            # Create semaphore for concurrent scan control
            self._semaphore = asyncio.Semaphore(self._concurrent_scans)
            
            # Initialize YARA rules
            rules_path = Path(__file__).parent / "rules"
            self.yara_rules = await self._load_yara_rules(rules_path)
            await self.register_resource(self.yara_rules)
            
            # Load signature database
            sig_path = Path(__file__).parent / "signatures"
            self.signature_db = await self._load_signatures(sig_path)
            
            self.logger.info("Binary Hunter initialized successfully")
            return True
            
        except Exception as e:
            raise InitializationError(f"Failed to initialize Binary Hunter: {str(e)}")

    async def _do_scan(self, target: ScanTarget, options: Dict[str, Any]) -> ScanResult:
        """
        Implement the actual scanning logic.
        
        Args:
            target: ScanTarget object containing path and metadata
            options: Scan configuration options including scan_type
            
        Returns:
            ScanResult: Results of the scan operation
        """
        scan_type = ScanType(options.get('scan_type', 'normal'))
        findings: Dict[str, Any] = {
            'threats': [],
            'scanned_files': [],
            'stats': {'total_files': 0, 'clean_files': 0, 'infected_files': 0}
        }
        errors: List[str] = []
        
        try:
            if target.is_directory:
                await self._scan_directory(target.path, scan_type, findings, errors)
            else:
                result = await self._scan_file(target.path, scan_type)
                self._update_findings(findings, result)
                
            return ScanResult(
                status=ScanStatus.COMPLETED,
                findings=findings,
                errors=errors,
                metadata={'scan_type': scan_type.value}
            )
            
        except Exception as e:
            raise ScanError(f"Scan failed: {str(e)}")

    async def _scan_file(self, file_path: Path, scan_type: ScanType) -> Dict[str, Any]:
        """Scan individual file using specified scan type."""
        async with self._semaphore:  # Control concurrent scans
            threats = []
            try:
                if not os.access(file_path, os.R_OK):
                    raise PermissionError(f"Cannot read file: {file_path}")
                
                # Update progress
                self.update_progress(
                    current_operation=f"Scanning {file_path.name}",
                    status_message="Processing file..."
                )
                
                # Quick scan - signature check only
                if scan_type in (ScanType.QUICK, ScanType.NORMAL, ScanType.DEEP):
                    sig_matches = await self._check_signatures(file_path)
                    threats.extend(sig_matches)
                
                # Normal scan adds YARA rules
                if scan_type in (ScanType.NORMAL, ScanType.DEEP):
                    yara_matches = await self._scan_yara(file_path)
                    threats.extend(yara_matches)
                
                # Deep scan adds heuristic analysis
                if scan_type == ScanType.DEEP:
                    heuristic_matches = await self._heuristic_scan(file_path)
                    threats.extend(heuristic_matches)
                
                return {
                    'file_path': str(file_path),
                    'threats': threats,
                    'scan_type': scan_type.value,
                    'status': 'completed'
                }
                
            except Exception as e:
                return {
                    'file_path': str(file_path),
                    'threats': [],
                    'scan_type': scan_type.value,
                    'status': 'error',
                    'error': str(e)
                }

    async def _scan_directory(self, dir_path: Path, scan_type: ScanType,
                            findings: Dict[str, Any], errors: List[str]) -> None:
        """Recursively scan directory with controlled concurrency."""
        try:
            total_files = sum(1 for _ in dir_path.rglob('*') if _.is_file())
            processed_files = 0
            
            async def process_file(file_path: Path):
                nonlocal processed_files
                result = await self._scan_file(file_path, scan_type)
                self._update_findings(findings, result)
                
                processed_files += 1
                self.update_progress(
                    percent_complete=(processed_files / total_files) * 100,
                    items_processed=processed_files,
                    items_total=total_files
                )
            
            tasks = []
            for file_path in dir_path.rglob('*'):
                if file_path.is_file():
                    tasks.append(asyncio.create_task(process_file(file_path)))
            
            await asyncio.gather(*tasks)
            
        except Exception as e:
            errors.append(f"Directory scan error: {str(e)}")

    async def _load_yara_rules(self, rules_path: Path) -> yara.Rules:
        """Load and compile YARA rules from rules directory."""
        rules_dict = {}
        
        for file_path in rules_path.glob('*.yar*'):
            try:
                content = await asyncio.to_thread(file_path.read_text)
                rules_dict[file_path.name] = content
            except Exception as e:
                self.logger.error(f"Failed to load YARA rule {file_path}: {str(e)}")
        
        return await asyncio.to_thread(yara.compile, sources=rules_dict)

    async def _load_signatures(self, sig_path: Path) -> Dict:
        """Load malware signatures from signature database."""
        try:
            # Implementation would load signatures from database
            # This is a placeholder for demonstration
            return {}
        except Exception as e:
            self.logger.error(f"Failed to load signatures: {str(e)}")
            return {}

    async def _check_signatures(self, file_path: Path) -> List[Dict]:
        """Check file against signature database."""
        threats = []
        try:
            file_hash = await asyncio.to_thread(self._calculate_hash, file_path)
            
            if file_hash in self.signature_db:
                threats.append({
                    'type': 'signature_match',
                    'signature': file_hash,
                    'threat': self.signature_db[file_hash]
                })
        except Exception as e:
            self.logger.error(f"Signature check failed for {file_path}: {str(e)}")
        
        return threats

    @staticmethod
    def _calculate_hash(file_path: Path) -> str:
        """Calculate SHA-256 hash of file."""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    async def _scan_yara(self, file_path: Path) -> List[Dict]:
        """Scan file with YARA rules."""
        threats = []
        try:
            matches = await asyncio.to_thread(
                self.yara_rules.match,
                str(file_path)
            )
            
            for match in matches:
                threats.append({
                    'type': 'yara_match',
                    'rule': match.rule,
                    'tags': match.tags,
                    'strings': match.strings
                })
        except Exception as e:
            self.logger.error(f"YARA scan failed for {file_path}: {str(e)}")
        
        return threats

    async def _heuristic_scan(self, file_path: Path) -> List[Dict]:
        """Perform heuristic analysis of file."""
        try:
            # Implementation would include various heuristic checks
            # This is a placeholder for demonstration
            return []
        except Exception as e:
            self.logger.error(f"Heuristic scan failed for {file_path}: {str(e)}")
            return []

    def _update_findings(self, findings: Dict[str, Any], result: Dict[str, Any]) -> None:
        """Update findings dictionary with results from single file scan."""
        findings['scanned_files'].append(result)
        findings['stats']['total_files'] += 1
        
        if result.get('status') == 'completed':
            if result['threats']:
                findings['stats']['infected_files'] += 1
                findings['threats'].extend(result['threats'])
            else:
                findings['stats']['clean_files'] += 1

    async def cleanup(self) -> None:
        """Clean up scanner resources."""
        try:
            self.yara_rules = None
            self.signature_db.clear()
            self._semaphore = None
            self.logger.info("Resources cleaned up successfully")
        except Exception as e:
            raise ResourceError(f"Cleanup failed: {str(e)}")