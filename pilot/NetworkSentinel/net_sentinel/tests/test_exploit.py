"""
Tests for Net-Sentinel Exploit Components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This module provides test cases for the exploitation components,
ensuring proper safety controls and validation.
"""

import pytest
import asyncio
from pathlib import Path
from datetime import datetime
from unittest.mock import Mock, patch, AsyncMock
import json

from net_sentinel.exploit import (
    ExploitExecutor,
    ExploitConfig,
    ExploitResult,
    ExploitType,
    ExploitStatus,
    SafeMode,
    ExploitValidator,
    DetailedValidator
)
from tests import BaseTestCase, async_test, TestConfig

class TestExploitExecutor(BaseTestCase):
    """Test cases for exploit execution functionality."""
    
    def setup_method(self, method):
        """Set up test method."""
        super().setup_method(method)
        self.executor = ExploitExecutor(safe_mode=SafeMode.SIMULATION)
        self.validator = ExploitValidator()
    
    async def asyncSetUp(self):
        """Set up async test components."""
        self.work_dir = Path(self.temp_dir)
        self.work_dir.mkdir(exist_ok=True)
    
    @pytest.mark.asyncio
    async def test_validate_and_run_simulation(self):
        """Test exploit simulation execution."""
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.VERSION_CHECK,
            parameters={
                "port": 80,
                "protocol": "http"
            },
            safe_mode=SafeMode.SIMULATION
        )
        
        result = await self.executor.validate_and_run(config)
        
        assert isinstance(result, ExploitResult)
        assert result.status == ExploitStatus.COMPLETED
        assert len(result.findings) > 0
        assert result.safety_hash is not None
    
    @pytest.mark.asyncio
    async def test_validate_config_rejection(self):
        """Test rejection of invalid configurations."""
        # Test with unsafe target
        config = ExploitConfig(
            target="127.0.0.1",  # Localhost should be rejected
            exploit_type=ExploitType.VERSION_CHECK,
            parameters={"port": 80}
        )
        
        result = await self.executor.validate_and_run(config)
        assert result.status == ExploitStatus.BLOCKED
        
        # Test with invalid parameters
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.VERSION_CHECK,
            parameters={"port": -1}  # Invalid port
        )
        
        result = await self.executor.validate_and_run(config)
        assert result.status == ExploitStatus.BLOCKED
    
    @pytest.mark.asyncio
    async def test_simulation_mode_safety(self):
        """Test safety controls in simulation mode."""
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.SERVICE_ENUMERATION,
            parameters={
                "ports": "1-1000",
                "protocol": "tcp"
            }
        )
        
        # Run in simulation mode
        result = await self.executor.validate_and_run(config)
        
        assert result.status != ExploitStatus.FAILED
        assert "simulation" in str(result.findings).lower()
        
        # Verify no actual connections were made
        # This would require mocking network calls to verify
    
    @pytest.mark.asyncio
    async def test_controlled_execution(self):
        """Test controlled execution mode with safety checks."""
        executor = ExploitExecutor(safe_mode=SafeMode.CONTROLLED)
        
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.CONFIGURATION_AUDIT,
            parameters={
                "service": "http",
                "depth": 1
            }
        )
        
        with patch('net_sentinel.exploit.executor.ExploitExecutor._check_execution_safety') as mock_safety:
            mock_safety.return_value = True
            result = await executor.validate_and_run(config)
            
            assert mock_safety.called
            assert result.status == ExploitStatus.COMPLETED
    
    @pytest.mark.asyncio
    async def test_exploit_result_tracking(self):
        """Test proper tracking of exploit execution results."""
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.INFORMATION_DISCLOSURE,
            parameters={"service": "http"}
        )
        
        start_time = datetime.now()
        result = await self.executor.validate_and_run(config)
        
        assert result.start_time >= start_time
        assert result.end_time is not None
        assert result.duration() > 0
        assert result.safety_hash is not None

class TestExploitValidator(BaseTestCase):
    """Test cases for exploit validation."""
    
    def setup_method(self, method):
        """Set up test method."""
        super().setup_method(method)
        self.validator = DetailedValidator()
    
    def test_target_validation(self):
        """Test target validation logic."""
        # Valid targets
        assert self.validator.validate_target("192.168.1.100").is_valid
        assert self.validator.validate_target("test-server.local").is_valid
        
        # Invalid targets
        assert not self.validator.validate_target("127.0.0.1").is_valid
        assert not self.validator.validate_target("0.0.0.0").is_valid
        assert not self.validator.validate_target("invalid!host").is_valid
    
    def test_parameter_validation(self):
        """Test exploit parameter validation."""
        # Test version check parameters
        result = self.validator.validate_parameters(
            ExploitType.VERSION_CHECK,
            {
                "service": "http",
                "port": 80,
                "technique": "banner"
            }
        )
        assert result.is_valid
        
        # Test invalid parameters
        result = self.validator.validate_parameters(
            ExploitType.VERSION_CHECK,
            {
                "service": "http",
                "port": -1  # Invalid port
            }
        )
        assert not result.is_valid
        assert "port" in str(result.errors)
    
    def test_execution_environment(self):
        """Test execution environment validation."""
        # Test simulation mode
        result = self.validator.validate_execution_environment(
            SafeMode.SIMULATION
        )
        assert result.is_valid
        
        # Test controlled mode
        result = self.validator.validate_execution_environment(
            SafeMode.CONTROLLED
        )
        assert result.is_valid
        assert "controlled_execution_safety" in result.details["checks_performed"]

class TestExploitConfig(BaseTestCase):
    """Test cases for exploit configuration."""
    
    def test_config_validation(self):
        """Test configuration validation."""
        # Valid configuration
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.VERSION_CHECK,
            parameters={
                "service": "http",
                "port": 80
            },
            timeout=30,
            max_retries=3
        )
        assert config.validate()
        
        # Invalid timeout
        with pytest.raises(ValueError):
            ExploitConfig(
                target="192.168.1.100",
                exploit_type=ExploitType.VERSION_CHECK,
                parameters={},
                timeout=-1
            ).validate()
        
        # Invalid retries
        with pytest.raises(ValueError):
            ExploitConfig(
                target="192.168.1.100",
                exploit_type=ExploitType.VERSION_CHECK,
                parameters={},
                max_retries=-1
            ).validate()
    
    def test_safety_hash(self):
        """Test safety hash generation."""
        config = ExploitConfig(
            target="192.168.1.100",
            exploit_type=ExploitType.VERSION_CHECK,
            parameters={"port": 80}
        )
        
        hash1 = config.get_safety_hash()
        assert isinstance(hash1, str)
        assert len(hash1) > 0
        
        # Same config should produce same hash
        hash2 = config.get_safety_hash()
        assert hash1 == hash2
        
        # Different config should produce different hash
        config.parameters["port"] = 443
        hash3 = config.get_safety_hash()
        assert hash1 != hash3

@pytest.fixture
def mock_exploit_executor():
    """Provide mock exploit executor."""
    executor = Mock(spec=ExploitExecutor)
    executor.validate_and_run = AsyncMock()
    executor.validate_and_run.return_value = ExploitResult(
        status=ExploitStatus.COMPLETED,
        findings={},
        start_time=datetime.now()
    )
    return executor

@pytest.fixture
def sample_exploit_config():
    """Provide sample exploit configuration."""
    return ExploitConfig(
        target="192.168.1.100",
        exploit_type=ExploitType.VERSION_CHECK,
        parameters={
            "service": "http",
            "port": 80,
            "technique": "banner"
        },
        timeout=30,
        max_retries=3,
        safe_mode=SafeMode.SIMULATION
    )