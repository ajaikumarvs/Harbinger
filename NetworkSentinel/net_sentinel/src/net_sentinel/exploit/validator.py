"""
Exploit Validator Module for Net-Sentinel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This module provides comprehensive validation and safety checks
for exploit configurations and execution environments.
"""

import logging
from typing import Dict, List, Any, Optional, Tuple
import ipaddress
import socket
import re
from pathlib import Path
import json
from dataclasses import dataclass
from datetime import datetime

from . import ExploitType, SafeMode

logger = logging.getLogger(__name__)

@dataclass
class ValidationResult:
    """Results of validation checks."""
    is_valid: bool
    errors: List[str]
    warnings: List[str]
    details: Dict[str, Any]
    timestamp: datetime = datetime.now()

    def to_dict(self) -> Dict[str, Any]:
        """Convert validation result to dictionary."""
        return {
            'is_valid': self.is_valid,
            'errors': self.errors,
            'warnings': self.warnings,
            'details': self.details,
            'timestamp': self.timestamp.isoformat()
        }

class DetailedValidator:
    """
    Provides detailed validation and safety checks for exploits.
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize the validator.
        
        Args:
            config_path: Optional path to validation configuration file
        """
        self.config_path = Path(config_path) if config_path else None
        self._load_validation_rules()
        
    def _load_validation_rules(self) -> None:
        """Load validation rules from configuration."""
        self.rules = {
            ExploitType.INFORMATION_DISCLOSURE: {
                'required_params': ['depth', 'timeout'],
                'optional_params': ['exclude_paths', 'follow_redirects'],
                'max_depth': 3
            },
            ExploitType.SERVICE_ENUMERATION: {
                'required_params': ['ports', 'protocols'],
                'optional_params': ['timeout', 'concurrent_scans'],
                'max_ports': 1000
            },
            ExploitType.VERSION_CHECK: {
                'required_params': ['service', 'port'],
                'optional_params': ['timeout', 'technique'],
                'valid_techniques': ['banner', 'probe', 'fingerprint']
            },
            ExploitType.CONFIGURATION_AUDIT: {
                'required_params': ['config_type', 'checks'],
                'optional_params': ['depth', 'exclude'],
                'valid_config_types': ['web', 'db', 'os', 'network']
            },
            ExploitType.PROTOCOL_ANALYSIS: {
                'required_params': ['protocol', 'depth'],
                'optional_params': ['timeout', 'capture_size'],
                'max_capture_size': 1024 * 1024  # 1MB
            }
        }
        
        # Load custom rules if configured
        if self.config_path and self.config_path.exists():
            try:
                with open(self.config_path) as f:
                    custom_rules = json.load(f)
                self.rules.update(custom_rules)
            except Exception as e:
                logger.error(f"Failed to load custom validation rules: {str(e)}")

    def validate_target(self, target: str) -> ValidationResult:
        """
        Validate target specification.
        
        Args:
            target: Target to validate
            
        Returns:
            ValidationResult with validation details
        """
        errors = []
        warnings = []
        details = {'target_type': 'unknown'}
        
        try:
            # Check if IP address
            ip = ipaddress.ip_address(target)
            details['target_type'] = 'ip'
            
            # Check if private IP
            if ip.is_private:
                warnings.append("Target is a private IP address")
            
            # Check if loopback
            if ip.is_loopback:
                errors.append("Loopback addresses are not allowed")
                
        except ValueError:
            try:
                # Check if hostname
                ip = socket.gethostbyname(target)
                details['target_type'] = 'hostname'
                details['resolved_ip'] = ip
                
                # Validate resolved IP
                resolved_ip = ipaddress.ip_address(ip)
                if resolved_ip.is_private:
                    warnings.append("Target resolves to private IP")
                if resolved_ip.is_loopback:
                    errors.append("Target resolves to loopback address")
                    
            except socket.error:
                errors.append(f"Unable to resolve target: {target}")
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            details=details
        )

    def validate_parameters(
        self,
        exploit_type: ExploitType,
        parameters: Dict[str, Any]
    ) -> ValidationResult:
        """
        Validate exploit parameters.
        
        Args:
            exploit_type: Type of exploit
            parameters: Parameters to validate
            
        Returns:
            ValidationResult with validation details
        """
        errors = []
        warnings = []
        details = {'validated_params': []}
        
        # Get validation rules for exploit type
        rules = self.rules.get(exploit_type)
        if not rules:
            errors.append(f"No validation rules for exploit type: {exploit_type}")
            return ValidationResult(False, errors, warnings, details)
        
        # Check required parameters
        for param in rules['required_params']:
            if param not in parameters:
                errors.append(f"Missing required parameter: {param}")
            else:
                details['validated_params'].append(param)
        
        # Validate parameter values
        if exploit_type == ExploitType.INFORMATION_DISCLOSURE:
            self._validate_info_disclosure_params(parameters, errors, warnings)
        elif exploit_type == ExploitType.SERVICE_ENUMERATION:
            self._validate_service_enum_params(parameters, errors, warnings)
        elif exploit_type == ExploitType.VERSION_CHECK:
            self._validate_version_check_params(parameters, errors, warnings)
        elif exploit_type == ExploitType.CONFIGURATION_AUDIT:
            self._validate_config_audit_params(parameters, errors, warnings)
        elif exploit_type == ExploitType.PROTOCOL_ANALYSIS:
            self._validate_protocol_analysis_params(parameters, errors, warnings)
        
        # Check for unknown parameters
        valid_params = rules['required_params'] + rules['optional_params']
        unknown_params = set(parameters.keys()) - set(valid_params)
        if unknown_params:
            warnings.append(f"Unknown parameters: {', '.join(unknown_params)}")
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            details=details
        )

    def validate_execution_environment(self, safe_mode: SafeMode) -> ValidationResult:
        """
        Validate execution environment.
        
        Args:
            safe_mode: Safety level for validation
            
        Returns:
            ValidationResult with validation details
        """
        errors = []
        warnings = []
        details = {
            'safe_mode': safe_mode.value,
            'checks_performed': []
        }
        
        # Validate environment based on safe mode
        if safe_mode == SafeMode.SIMULATION:
            details['checks_performed'].append('simulation_safety')
        elif safe_mode == SafeMode.VALIDATION:
            details['checks_performed'].extend([
                'simulation_safety',
                'validation_safety'
            ])
        elif safe_mode == SafeMode.CONTROLLED:
            result = self._validate_controlled_environment()
            errors.extend(result.errors)
            warnings.extend(result.warnings)
            details['checks_performed'].extend([
                'simulation_safety',
                'validation_safety',
                'controlled_execution_safety'
            ])
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            details=details
        )

    def _validate_info_disclosure_params(
        self,
        parameters: Dict[str, Any],
        errors: List[str],
        warnings: List[str]
    ) -> None:
        """Validate information disclosure parameters."""
        if 'depth' in parameters:
            depth = parameters['depth']
            if not isinstance(depth, int) or depth < 1:
                errors.append("Depth must be a positive integer")
            elif depth > self.rules[ExploitType.INFORMATION_DISCLOSURE]['max_depth']:
                errors.append(f"Depth exceeds maximum allowed: {depth}")

    def _validate_service_enum_params(
        self,
        parameters: Dict[str, Any],
        errors: List[str],
        warnings: List[str]
    ) -> None:
        """Validate service enumeration parameters."""
        if 'ports' in parameters:
            ports = parameters['ports']
            if isinstance(ports, str):
                if not self._validate_port_range(ports):
                    errors.append("Invalid port range format")
            elif isinstance(ports, list):
                if not all(isinstance(p, int) and 1 <= p <= 65535 for p in ports):
                    errors.append("Invalid port numbers in list")
            else:
                errors.append("Ports must be string range or list of integers")

    def _validate_version_check_params(
        self,
        parameters: Dict[str, Any],
        errors: List[str],
        warnings: List[str]
    ) -> None:
        """Validate version check parameters."""
        if 'technique' in parameters:
            technique = parameters['technique']
            valid_techniques = self.rules[ExploitType.VERSION_CHECK]['valid_techniques']
            if technique not in valid_techniques:
                errors.append(f"Invalid technique: {technique}")

    def _validate_config_audit_params(
        self,
        parameters: Dict[str, Any],
        errors: List[str],
        warnings: List[str]
    ) -> None:
        """Validate configuration audit parameters."""
        if 'config_type' in parameters:
            config_type = parameters['config_type']
            valid_types = self.rules[ExploitType.CONFIGURATION_AUDIT]['valid_config_types']
            if config_type not in valid_types:
                errors.append(f"Invalid configuration type: {config_type}")

    def _validate_protocol_analysis_params(
        self,
        parameters: Dict[str, Any],
        errors: List[str],
        warnings: List[str]
    ) -> None:
        """Validate protocol analysis parameters."""
        if 'capture_size' in parameters:
            size = parameters['capture_size']
            max_size = self.rules[ExploitType.PROTOCOL_ANALYSIS]['max_capture_size']
            if size > max_size:
                errors.append(f"Capture size exceeds maximum allowed: {size}")

    def _validate_controlled_environment(self) -> ValidationResult:
        """Validate environment for controlled execution."""
        errors = []
        warnings = []
        details = {'environment_checks': []}
        
        # Implement environment-specific checks
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            details=details
        )

    def _validate_port_range(self, port_range: str) -> bool:
        """Validate port range string format."""
        pattern = r'^\d+(?:-\d+)?(?:,\d+(?:-\d+)?)*$'
        if not re.match(pattern, port_range):
            return False
        
        try:
            for part in port_range.split(','):
                if '-' in part:
                    start, end = map(int, part.split('-'))
                    if not (1 <= start <= end <= 65535):
                        return False
                else:
                    port = int(part)
                    if not (1 <= port <= 65535):
                        return False
            return True
        except ValueError:
            return False