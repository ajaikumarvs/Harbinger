"""
Vulnerability Scanner Module for Net-Sentinel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This module provides vulnerability scanning capabilities with
multiple scanning techniques and comprehensive safety controls.
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional, Set
import ipaddress
import socket
from datetime import datetime
import ssl
import re
import aiohttp
from concurrent.futures import ThreadPoolExecutor
import json

from . import (
    Vulnerability,
    VulnerabilityType,
    Severity,
    ScanConfig,
    ScanError
)
from ..network import (
    NetworkDiscovery,
    ServiceDetector,
    Host,
    Service
)
from .analyzer import VulnerabilityAnalyzer, AnalysisContext

logger = logging.getLogger(__name__)

class ServiceCheck:
    """Service-specific vulnerability check."""
    def __init__(
        self,
        name: str,
        ports: List[int],
        protocol: str,
        patterns: List[str]
    ):
        self.name = name
        self.ports = ports
        self.protocol = protocol
        self.patterns = patterns

class VulnerabilityScanner:
    """
    Handles vulnerability scanning operations.
    """
    
    def __init__(self):
        """Initialize the vulnerability scanner."""
        self.network_discovery = NetworkDiscovery()
        self.service_detector = ServiceDetector()
        self.analyzer = VulnerabilityAnalyzer()
        self._executor = ThreadPoolExecutor(max_workers=5)
        self._load_service_checks()
    
    def _load_service_checks(self) -> None:
        """Load service vulnerability checks."""
        self.service_checks = {
            "http": ServiceCheck(
                name="HTTP",
                ports=[80, 8080, 8000],
                protocol="tcp",
                patterns=[
                    r"Server:\s*([^\r\n]+)",
                    r"X-Powered-By:\s*([^\r\n]+)"
                ]
            ),
            "https": ServiceCheck(
                name="HTTPS",
                ports=[443, 8443],
                protocol="tcp",
                patterns=[
                    r"SSL\s+Version:\s*([^\r\n]+)",
                    r"Certificate:\s*([^\r\n]+)"
                ]
            ),
            "ssh": ServiceCheck(
                name="SSH",
                ports=[22],
                protocol="tcp",
                patterns=[
                    r"SSH-\d+\.\d+-([^\r\n]+)",
                    r"Protocol\s+version\s+\d+\.\d+"
                ]
            ),
            "ftp": ServiceCheck(
                name="FTP",
                ports=[21],
                protocol="tcp",
                patterns=[
                    r"220[\s-]([^\r\n]+)",
                    r"230\s+Login\s+successful"
                ]
            ),
            "smtp": ServiceCheck(
                name="SMTP",
                ports=[25, 587],
                protocol="tcp",
                patterns=[
                    r"220[\s-]([^\r\n]+)",
                    r"AUTH\s+([^\r\n]+)"
                ]
            )
        }
    
    async def scan_target(
        self,
        target: str,
        config: Optional[ScanConfig] = None
    ) -> List[Vulnerability]:
        """
        Scan target for vulnerabilities.
        
        Args:
            target: Target specification
            config: Optional scan configuration
            
        Returns:
            List of discovered vulnerabilities
            
        Raises:
            ScanError: If scan fails
        """
        try:
            config = config or ScanConfig()
            config.validate()
            
            # Discover hosts
            hosts = await self.network_discovery.scan_network(target)
            
            # Scan each host
            all_vulnerabilities = []
            for host in hosts:
                vulnerabilities = await self.scan_host(host, config)
                all_vulnerabilities.extend(vulnerabilities)
            
            # Analyze dependencies
            self.analyzer.analyze_dependencies(all_vulnerabilities)
            
            # Enrich findings
            enriched = await self.analyzer.enrich_vulnerabilities(
                all_vulnerabilities
            )
            
            return enriched
            
        except Exception as e:
            logger.error(f"Scan failed: {str(e)}")
            raise ScanError(f"Scan failed: {str(e)}")
    
    async def scan_host(
        self,
        host: Host,
        config: ScanConfig
    ) -> List[Vulnerability]:
        """
        Scan single host for vulnerabilities.
        
        Args:
            host: Host to scan
            config: Scan configuration
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        # Create analysis context
        context = AnalysisContext(
            target_type="host",
            environment="network",
            scan_depth=config.max_depth,
            timestamp=datetime.now(),
            affected_services=[]
        )
        
        try:
            # Detect services
            services = await self.service_detector.detect_multiple(
                host=host.ip,
                ports=host.ports
            )
            
            # Update context with services
            context.affected_services = [
                s.service for s in services if s.service
            ]
            
            # Scan services
            service_vulns = await self._scan_services(
                host.ip,
                services,
                config
            )
            vulnerabilities.extend(service_vulns)
            
            # Scan configurations
            if VulnerabilityType.CONFIGURATION in config.scan_types:
                config_vulns = await self._scan_configurations(
                    host.ip,
                    services,
                    config
                )
                vulnerabilities.extend(config_vulns)
            
            # Scan authentication
            if VulnerabilityType.AUTHENTICATION in config.scan_types:
                auth_vulns = await self._scan_authentication(
                    host.ip,
                    services,
                    config
                )
                vulnerabilities.extend(auth_vulns)
            
            # Analyze findings
            analyzed_vulns = []
            for finding in vulnerabilities:
                analyzed = await self.analyzer.analyze_vulnerability(
                    finding,
                    context
                )
                analyzed_vulns.append(analyzed)
            
            return analyzed_vulns
            
        except Exception as e:
            logger.error(f"Host scan failed for {host.ip}: {str(e)}")
            return vulnerabilities
    
    async def _scan_services(
        self,
        host: str,
        services: List[Service],
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Scan services for vulnerabilities."""
        findings = []
        
        for service in services:
            if not service.service:
                continue
            
            # Get service check
            check = self.service_checks.get(service.service.lower())
            if not check:
                continue
            
            # Perform service checks
            service_findings = await self._check_service(
                host,
                service,
                check,
                config
            )
            findings.extend(service_findings)
        
        return findings
    
    async def _check_service(
        self,
        host: str,
        service: Service,
        check: ServiceCheck,
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Check service for vulnerabilities."""
        findings = []
        
        try:
            # Connect to service
            if service.protocol == "tcp":
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, service.port),
                    timeout=config.timeout
                )
                
                try:
                    # Send probe
                    if check.name == "HTTP":
                        writer.write(b"HEAD / HTTP/1.0\r\n\r\n")
                    elif check.name == "SSH":
                        pass  # SSH banner is automatic
                    
                    await writer.drain()
                    
                    # Read response
                    response = await reader.read(4096)
                    response_str = response.decode('utf-8', 'ignore')
                    
                    # Check patterns
                    for pattern in check.patterns:
                        match = re.search(pattern, response_str)
                        if match:
                            findings.append({
                                'title': f'Service Detection: {check.name}',
                                'description': (
                                    f'Service information disclosed: {match.group(1)}'
                                ),
                                'service': service.service,
                                'port': service.port,
                                'protocol': service.protocol,
                                'raw_data': response_str
                            })
                    
                finally:
                    writer.close()
                    await writer.wait_closed()
            
        except Exception as e:
            logger.debug(
                f"Service check failed for {host}:{service.port}: {str(e)}"
            )
        
        return findings
    
    async def _scan_configurations(
        self,
        host: str,
        services: List[Service],
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Scan service configurations."""
        findings = []
        
        for service in services:
            if service.service == "http":
                # Check HTTP configuration
                http_findings = await self._check_http_config(
                    host,
                    service.port,
                    config
                )
                findings.extend(http_findings)
            elif service.service == "ssh":
                # Check SSH configuration
                ssh_findings = await self._check_ssh_config(
                    host,
                    service.port,
                    config
                )
                findings.extend(ssh_findings)
        
        return findings
    
    async def _check_http_config(
        self,
        host: str,
        port: int,
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Check HTTP server configuration."""
        findings = []
        
        try:
            async with aiohttp.ClientSession() as session:
                # Check security headers
                url = f"http://{host}:{port}"
                async with session.get(url) as response:
                    headers = response.headers
                    
                    # Check for missing security headers
                    security_headers = {
                        'X-Frame-Options': 'Missing X-Frame-Options header',
                        'X-Content-Type-Options': (
                            'Missing X-Content-Type-Options header'
                        ),
                        'X-XSS-Protection': 'Missing X-XSS-Protection header',
                        'Content-Security-Policy': (
                            'Missing Content-Security-Policy header'
                        )
                    }
                    
                    for header, message in security_headers.items():
                        if header not in headers:
                            findings.append({
                                'title': f'Missing Security Header: {header}',
                                'description': message,
                                'service': 'http',
                                'port': port,
                                'severity': 'low'
                            })
        
        except Exception as e:
            logger.debug(f"HTTP config check failed: {str(e)}")
        
        return findings
    
    async def _check_ssh_config(
        self,
        host: str,
        port: int,
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Check SSH server configuration."""
        findings = []
        
        try:
            # Connect and get banner
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=config.timeout
            )
            
            try:
                banner = await reader.readline()
                banner_str = banner.decode('utf-8', 'ignore')
                
                # Check for old versions
                if 'SSH-1' in banner_str:
                    findings.append({
                        'title': 'Obsolete SSH Version',
                        'description': (
                            'Server supports obsolete SSH version 1'
                        ),
                        'service': 'ssh',
                        'port': port,
                        'severity': 'high'
                    })
            
            finally:
                writer.close()
                await writer.wait_closed()
        
        except Exception as e:
            logger.debug(f"SSH config check failed: {str(e)}")
        
        return findings
    
    async def _scan_authentication(
        self,
        host: str,
        services: List[Service],
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Scan authentication mechanisms."""
        findings = []
        
        for service in services:
            if service.service == "http":
                # Check for basic auth
                auth_findings = await self._check_http_auth(
                    host,
                    service.port,
                    config
                )
                findings.extend(auth_findings)
        
        return findings
    
    async def _check_http_auth(
        self,
        host: str,
        port: int,
        config: ScanConfig
    ) -> List[Dict[str, Any]]:
        """Check HTTP authentication."""
        findings = []
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"http://{host}:{port}"
                async with session.get(url) as response:
                    if 'WWW-Authenticate' in response.headers:
                        auth_type = response.headers['WWW-Authenticate']
                        if 'Basic' in auth_type:
                            findings.append({
                                'title': 'Basic Authentication in Use',
                                'description': (
                                    'Server uses basic authentication, which '
                                    'transmits credentials in base64 encoding'
                                ),
                                'service': 'http',
                                'port': port,
                                'severity': 'medium'
                            })
        
        except Exception as e:
            logger.debug(f"HTTP auth check failed: {str(e)}")
        
        return findings
    
    def __del__(self):
        """Cleanup resources."""
        if self._executor:
            self._executor.shutdown(wait=True)