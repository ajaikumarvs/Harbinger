"""
Vulnerability Analyzer Module for Net-Sentinel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This module handles vulnerability analysis, classification,
and risk assessment of discovered security findings.
"""

import logging
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
import json
import re
import math
from dataclasses import dataclass
import aiohttp
import asyncio

from . import (
    Vulnerability,
    VulnerabilityType,
    Severity,
    ExploitStatus,
    CVSSScore
)

logger = logging.getLogger(__name__)

@dataclass
class AnalysisContext:
    """Context information for vulnerability analysis."""
    target_type: str
    environment: str
    scan_depth: int
    timestamp: datetime
    affected_services: List[str]

class VulnerabilityAnalyzer:
    """
    Analyzes and classifies discovered vulnerabilities.
    """
    
    def __init__(self, vuln_db_path: Optional[str] = None):
        """
        Initialize the analyzer.
        
        Args:
            vuln_db_path: Optional path to vulnerability database
        """
        self.vuln_db = self._load_vuln_database(vuln_db_path)
        self._load_analysis_patterns()
    
    def _load_vuln_database(
        self,
        db_path: Optional[str]
    ) -> Dict[str, Any]:
        """Load vulnerability database."""
        if db_path:
            try:
                with open(db_path) as f:
                    return json.load(f)
            except Exception as e:
                logger.warning(f"Failed to load vulnerability database: {e}")
        return {}
    
    def _load_analysis_patterns(self) -> None:
        """Load vulnerability analysis patterns."""
        self.patterns = {
            VulnerabilityType.NETWORK: {
                'port_scan': r'port\s+(\d+)\s+is\s+open',
                'service_banner': r'banner:\s+"([^"]+)"',
                'protocol_version': r'protocol\s+version:\s+(\d+(?:\.\d+)*)'
            },
            VulnerabilityType.SERVICE: {
                'version_info': r'version:\s+([^\s]+)',
                'weak_config': r'weak\s+configuration:\s+([^\n]+)',
                'default_creds': r'default\s+credentials:\s+([^\n]+)'
            },
            VulnerabilityType.AUTHENTICATION: {
                'weak_auth': r'weak\s+authentication\s+method:\s+([^\n]+)',
                'missing_auth': r'missing\s+authentication',
                'auth_bypass': r'authentication\s+bypass\s+possible'
            }
        }
    
    async def analyze_vulnerability(
        self,
        finding: Dict[str, Any],
        context: Optional[AnalysisContext] = None
    ) -> Vulnerability:
        """
        Analyze and classify a vulnerability finding.
        
        Args:
            finding: Raw vulnerability finding
            context: Optional analysis context
            
        Returns:
            Classified Vulnerability object
        """
        # Determine vulnerability type
        vuln_type = self._determine_vulnerability_type(finding)
        
        # Calculate severity
        severity, cvss = await self._calculate_severity(finding)
        
        # Check for known CVEs
        cve_ids = await self._find_cve_matches(finding)
        
        # Determine exploit status
        exploit_status = await self._check_exploit_status(finding, cve_ids)
        
        # Build vulnerability object
        vulnerability = Vulnerability(
            id=self._generate_vuln_id(finding),
            title=finding['title'],
            description=finding['description'],
            severity=severity,
            vulnerability_type=vuln_type,
            cvss_score=cvss,
            cve_ids=cve_ids,
            affected_components=self._get_affected_components(finding),
            proof_of_concept=finding.get('proof_of_concept'),
            remediation=self._generate_remediation(finding, vuln_type),
            references=finding.get('references', []),
            exploit_status=exploit_status,
            technical_details=self._extract_technical_details(finding)
        )
        
        # Enhance with context if available
        if context:
            self._enhance_with_context(vulnerability, context)
        
        return vulnerability
    
    def analyze_dependencies(
        self,
        findings: List[Vulnerability]
    ) -> Dict[str, List[str]]:
        """
        Analyze dependencies between vulnerabilities.
        
        Args:
            findings: List of vulnerabilities
            
        Returns:
            Dictionary mapping vulnerability IDs to dependent vuln IDs
        """
        dependencies = {}
        
        for vuln in findings:
            dependencies[vuln.id] = []
            
            # Check for dependencies based on affected components
            for other in findings:
                if vuln.id != other.id:
                    if self._check_dependency(vuln, other):
                        dependencies[vuln.id].append(other.id)
        
        return dependencies
    
    async def enrich_vulnerabilities(
        self,
        vulnerabilities: List[Vulnerability]
    ) -> List[Vulnerability]:
        """
        Enrich vulnerability information using external sources.
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Enriched vulnerability list
        """
        enriched = []
        
        async with aiohttp.ClientSession() as session:
            tasks = [
                self._enrich_vulnerability(vuln, session)
                for vuln in vulnerabilities
            ]
            enriched = await asyncio.gather(*tasks)
        
        return enriched
    
    def _determine_vulnerability_type(
        self,
        finding: Dict[str, Any]
    ) -> VulnerabilityType:
        """Determine vulnerability type from finding."""
        # Check each type's patterns
        for vuln_type, patterns in self.patterns.items():
            for pattern in patterns.values():
                if any(
                    re.search(pattern, str(value), re.I)
                    for value in finding.values()
                ):
                    return vuln_type
        
        # Default to network if no patterns match
        return VulnerabilityType.NETWORK
    
    async def _calculate_severity(
        self,
        finding: Dict[str, Any]
    ) -> Tuple[Severity, Optional[CVSSScore]]:
        """Calculate severity and CVSS score."""
        # Try to extract CVSS vector
        cvss_vector = finding.get('cvss_vector')
        if cvss_vector:
            cvss_score = await self._calculate_cvss(cvss_vector)
            severity = self._cvss_to_severity(cvss_score.base_score)
            return severity, cvss_score
        
        # Fallback to heuristic severity calculation
        severity = self._calculate_heuristic_severity(finding)
        return severity, None
    
    async def _calculate_cvss(self, vector: str) -> CVSSScore:
        """Calculate CVSS score from vector string."""
        # Parse CVSS vector and calculate scores
        base_score = self._calculate_base_score(vector)
        temporal_score = self._calculate_temporal_score(vector, base_score)
        environmental_score = self._calculate_environmental_score(
            vector,
            base_score
        )
        
        return CVSSScore(
            base_score=base_score,
            temporal_score=temporal_score,
            environmental_score=environmental_score,
            vector_string=vector
        )
    
    def _calculate_base_score(self, vector: str) -> float:
        """Calculate CVSS base score."""
        # Implement CVSS base score calculation
        # This is a simplified calculation
        impact_factors = {
            'AV:N': 0.85,  # Network
            'AC:L': 0.77,  # Low complexity
            'PR:N': 0.85,  # No privileges required
            'UI:N': 0.85,  # No user interaction
            'S:C': 1.0,    # Scope changed
            'C:H': 0.56,   # High confidentiality
            'I:H': 0.56,   # High integrity
            'A:H': 0.56    # High availability
        }
        
        score = 0
        for factor, weight in impact_factors.items():
            if factor in vector:
                score += weight
        
        return min(10.0, score)
    
    def _calculate_temporal_score(
        self,
        vector: str,
        base_score: float
    ) -> float:
        """Calculate CVSS temporal score."""
        # Simplified temporal score calculation
        temporal_factors = {
            'E:F': 0.97,  # Functional exploit
            'RL:O': 0.95, # Official fix
            'RC:C': 1.0   # Confirmed
        }
        
        modifier = 1.0
        for factor, weight in temporal_factors.items():
            if factor in vector:
                modifier *= weight
        
        return round(base_score * modifier, 1)
    
    def _calculate_environmental_score(
        self,
        vector: str,
        base_score: float
    ) -> float:
        """Calculate CVSS environmental score."""
        # Simplified environmental score calculation
        env_factors = {
            'CR:H': 1.5,  # High confidentiality requirement
            'IR:H': 1.5,  # High integrity requirement
            'AR:H': 1.5   # High availability requirement
        }
        
        modifier = 1.0
        for factor, weight in env_factors.items():
            if factor in vector:
                modifier *= weight
        
        return round(base_score * modifier, 1)
    
    def _cvss_to_severity(self, cvss_score: float) -> Severity:
        """Convert CVSS score to severity level."""
        if cvss_score >= 9.0:
            return Severity.CRITICAL
        elif cvss_score >= 7.0:
            return Severity.HIGH
        elif cvss_score >= 4.0:
            return Severity.MEDIUM
        elif cvss_score >= 0.1:
            return Severity.LOW
        return Severity.INFO
    
    def _calculate_heuristic_severity(
        self,
        finding: Dict[str, Any]
    ) -> Severity:
        """Calculate severity using heuristics."""
        # Define severity indicators
        indicators = {
            Severity.CRITICAL: [
                'remote code execution',
                'privilege escalation',
                'authentication bypass',
                'critical'
            ],
            Severity.HIGH: [
                'sql injection',
                'command injection',
                'credentials exposed',
                'high'
            ],
            Severity.MEDIUM: [
                'cross-site scripting',
                'information disclosure',
                'weak encryption',
                'medium'
            ],
            Severity.LOW: [
                'missing headers',
                'version disclosure',
                'low'
            ]
        }
        
        # Check finding against indicators
        finding_text = json.dumps(finding).lower()
        for severity, patterns in indicators.items():
            if any(pattern in finding_text for pattern in patterns):
                return severity
        
        return Severity.INFO
    
    async def _find_cve_matches(
        self,
        finding: Dict[str, Any]
    ) -> List[str]:
        """Find matching CVE IDs."""
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        matches = []
        
        # Search in all text fields
        for value in finding.values():
            if isinstance(value, str):
                matches.extend(re.findall(cve_pattern, value))
        
        # Search vulnerability database
        db_matches = self._search_vuln_db(finding)
        matches.extend(db_matches)
        
        return list(set(matches))
    
    def _search_vuln_db(self, finding: Dict[str, Any]) -> List[str]:
        """Search vulnerability database for matches."""
        matches = []
        
        if not self.vuln_db:
            return matches
        
        # Search for matching patterns
        finding_text = json.dumps(finding).lower()
        for vuln_id, vuln_data in self.vuln_db.items():
            if vuln_data.get('pattern') and re.search(
                vuln_data['pattern'],
                finding_text,
                re.I
            ):
                matches.append(vuln_id)
        
        return matches
    
    async def _check_exploit_status(
        self,
        finding: Dict[str, Any],
        cve_ids: List[str]
    ) -> ExploitStatus:
        """Check exploit availability status."""
        if finding.get('exploit_available') is True:
            return ExploitStatus.CONFIRMED
        
        # Check CVEs for known exploits
        if cve_ids:
            for cve_id in cve_ids:
                if await self._check_exploit_databases(cve_id):
                    return ExploitStatus.CONFIRMED
        
        # Check for potential exploitability
        if self._check_potential_exploitability(finding):
            return ExploitStatus.POTENTIAL
        
        return ExploitStatus.UNKNOWN
    
    async def _check_exploit_databases(self, cve_id: str) -> bool:
        """Check exploit databases for CVE."""
        # Implement checks against exploit databases
        return False
    
    def _check_potential_exploitability(
        self,
        finding: Dict[str, Any]
    ) -> bool:
        """Check if vulnerability is potentially exploitable."""
        # Implement exploitability checks
        return False
    
    def _get_affected_components(
        self,
        finding: Dict[str, Any]
    ) -> List[str]:
        """Get list of affected components."""
        components = []
        
        # Extract from explicit field
        if 'affected_components' in finding:
            components.extend(finding['affected_components'])
        
        # Extract from description
        if 'description' in finding:
            # Look for component patterns
            component_pattern = r'(?:affects|in|on)\s+([a-zA-Z0-9_.-]+)'
            matches = re.findall(component_pattern, finding['description'], re.I)
            components.extend(matches)
        
        return list(set(components))
    
    def _generate_remediation(
        self,
        finding: Dict[str, Any],
        vuln_type: VulnerabilityType
    ) -> str:
        """Generate remediation guidance."""
        if 'remediation' in finding:
            return finding['remediation']
        
        # Generate based on vulnerability type
        remediation_templates = {
            VulnerabilityType.NETWORK: (
                "1. Review and restrict network access\n"
                "2. Implement proper firewall rules\n"
                "3. Consider network segmentation"
            ),
            VulnerabilityType.SERVICE: (
                "1. Update service to latest version\n"
                "2. Apply security patches\n"
                "3. Review service configuration"
            ),
            VulnerabilityType.AUTHENTICATION: (
                "1. Implement strong authentication\n"
                "2. Enable multi-factor authentication\n"
                "3. Review access controls"
            )
        }
        
        return remediation_templates.get(
            vuln_type,
            "1. Review and update security settings\n"
            "2. Monitor for suspicious activity\n"
            "3. Implement security best practices"
        )
    
    def _extract_technical_details(
        self,
        finding: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Extract technical details from finding."""
        details = {}
        
        # Extract version information
        version_pattern = r'version[\s:]+([0-9.]+)'
        if 'raw_data' in finding:
            version_match = re.search(version_pattern, str(finding['raw_data']))
            if version_match:
                details['version'] = version_match.group(1)
        
        # Extract port information
        port_pattern = r'port\s+(\d+)'
        port_matches = re.findall(port_pattern, str(finding))
        if port_matches:
            details['ports'] = port_matches
        
        # Add protocol information
        if 'protocol' in finding:
            details['protocol'] = finding['protocol']
        
        # Add any specific technical data
        if 'technical_details' in finding:
            details.update(finding['technical_details'])
        
        return details
    
    def _generate_vuln_id(self, finding: Dict[str, Any]) -> str:
        """Generate unique vulnerability ID."""
        # Create base string for hashing
        base = f"{finding['title']}:{finding.get('description', '')}"
        
        # Add timestamp for uniqueness
        base += f":{datetime.now().isoformat()}"
        
        # Generate hash
        return f"VULN-{hash(base) & 0xffffffff:08x}"
    
    def _enhance_with_context(
        self,
        vulnerability: Vulnerability,
        context: AnalysisContext
    ) -> None:
        """Enhance vulnerability with context information."""
        # Add environment information
        vulnerability.technical_details['environment'] = context.environment
        
        # Add affected services from context
        if context.affected_services:
            vulnerability.technical_details['affected_services'] = (
                context.affected_services
            )
        
        # Add scan depth information
        vulnerability.technical_details['scan_depth'] = context.scan_depth
        
        # Add target type
        vulnerability.technical_details['target_type'] = context.target_type
    
    def _check_dependency(
        self,
        vuln1: Vulnerability,
        vuln2: Vulnerability
    ) -> bool:
        """Check if vulnerabilities are dependent."""
        # Check component overlap
        common_components = set(vuln1.affected_components) & set(
            vuln2.affected_components
        )
        if common_components:
            return True
        
        # Check if one vulnerability enables another
        if vuln1.vulnerability_type == VulnerabilityType.AUTHENTICATION:
            return vuln2.vulnerability_type in [
                VulnerabilityType.INFORMATION_DISCLOSURE,
                VulnerabilityType.ACCESS_CONTROL
            ]
        
        return False
    
    async def _enrich_vulnerability(
        self,
        vulnerability: Vulnerability,
        session: aiohttp.ClientSession
    ) -> Vulnerability:
        """Enrich vulnerability with additional information."""
        # Enrich CVE information
        if vulnerability.cve_ids:
            cve_details = await self._fetch_cve_details(
                vulnerability.cve_ids[0],
                session
            )
            if cve_details:
                vulnerability.technical_details['cve_details'] = cve_details
        
        # Add exploitation details if available
        if vulnerability.exploit_status == ExploitStatus.CONFIRMED:
            exploit_details = await self._fetch_exploit_details(
                vulnerability,
                session
            )
            if exploit_details:
                vulnerability.technical_details['exploit_details'] = exploit_details
        
        return vulnerability
    
    async def _fetch_cve_details(
        self,
        cve_id: str,
        session: aiohttp.ClientSession
    ) -> Optional[Dict[str, Any]]:
        """Fetch CVE details from NVD."""
        try:
            # Note: Replace with actual NVD API endpoint
            url = f"https://api.example.com/nvd/{cve_id}"
            async with session.get(url) as response:
                if response.status == 200:
                    return await response.json()
        except Exception as e:
            logger.debug(f"Failed to fetch CVE details: {e}")
        return None
    
    async def _fetch_exploit_details(
        self,
        vulnerability: Vulnerability,
        session: aiohttp.ClientSession
    ) -> Optional[Dict[str, Any]]:
        """Fetch exploit details from security databases."""
        try:
            # Note: Replace with actual exploit database API endpoint
            url = "https://api.example.com/exploits/search"
            data = {
                "cve_ids": vulnerability.cve_ids,
                "title": vulnerability.title
            }
            async with session.post(url, json=data) as response:
                if response.status == 200:
                    return await response.json()
        except Exception as e:
            logger.debug(f"Failed to fetch exploit details: {e}")
        return None